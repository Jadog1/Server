<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Distance calculator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <%- include('../partials/Header') %>
</head>
<body>

    <!-- Navbar -->
    <%- include('../partials/navbar') %>
    <style>
        #optionPane {
            width: 100%;
            height: 100px;
            background-color: #eee;
        }

        input[type="radio"],
        label {
            cursor: pointer;
        }

        textarea {
            display: inline-block;
            margin-right: 20px;
        }

        #help {
            display: inline-block;
            float: right;
            cursor: pointer;
        }
    </style>

    <div class="w3-row-padding w3-padding-64 w3-container">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
        <div id="optionPane">
            <div id="help" onclick="displayHelp()">
                <i class="fa fa-question-circle">Help</i>
            </div>
            <input id="efficient" type="radio" name="sort" checked="checked" onclick="calculation = 0" />
            <label for="efficient">Sort by shipping efficiency</label><br />
            <input id="fair" type="radio" name="sort" onclick="calculation = 1" />
            <label for="fair">Sort by fairness (In beta). If you encounter off cases, please send a screenshot to Jadon Steinmetz</label>

            <a href="/projects/distanceNew" style="float:right"><h4>Click here to view the legacy algorithm</h4></a>
        </div>

        <textarea placeholder="Insert addresses here" rows="20" cols="40" id="input"></textarea>
        <textarea readonly rows="20" cols="40" id="output" placeholder="output"></textarea>
        <br />
        <button onclick="chooseCalc()">
            Calculate
        </button>
        FTW: <span id="ftw">0</span>
        OMA: <span id="oma">0</span>
        GSO: <span id="gso">0</span>
        <button onclick="clearVals()">
            Clear
        </button> <br />
        <h1>Efficiency</h1>
        <p>
            I am currently working on changing the algorithm for both fairness and efficiency algorithms. As of right now, the efficiency algorithm is using the new algorithm that I designed that relies on km distance between states, as opposed to my previous setup which relied on basic graph theory and grouping of states. This should help to improve overall speed, and accuracy, of location pickings.
        </p>
    </div>


    <script>
        var cachedDistances;
        var cachedStateLocations = [];
        //Find the current state depots, which is kept up to date on a JSON file
        $(document).ready(function () {
            $.get("/currentDepots", function (data) {
                cachedDistances = data;
                //The below loop is to quickly find the states by using an "associate" array
                for (var i = 0; i < data[0].distances.length; i++) {
                    cachedStateLocations[data[0].distances[i].name] = i;
                }
            });
        });
        function depotObj(name, state) {
            this.name = name;
            this.state = state;
            this.assigned = 0;
        }
        var depotList = [new depotObj("FTW", "IN"), new depotObj("OMA", "NE"), new depotObj("GSO", "NC")]

        function clearVals() {
            for (i = 0; i < depotList.length; i++) depotList[i].assigned = 0;
            document.getElementById("output").innerHTML = "";
            document.getElementById("input").value = "";
            document.getElementById("ftw").innerHTML = depotList[0].assigned;
            document.getElementById("oma").innerHTML = depotList[1].assigned;
            document.getElementById("gso").innerHTML = depotList[2].assigned;
        }

        var calculation = 0;
        function chooseCalc() {
            for (i = 0; i < depotList.length; i++) depotList[i].assigned = 0;
            document.getElementById("output").innerHTML = "";

            if (calculation == 0) {
                calculateDistanceEfficient();
            } else calculateDistanceFair();
        }

        function calculateDistanceEfficient() {
            document.getElementById("output").innerHTML = "";
            //Split the list and set the arrays
            var list = document.getElementById("input").value;
            list = list.trim();
            list = list.split("\n");
            for (var i = 0; i < list.length; i++) {
                //Logic for handling reading full addresses and state abbreviations
                var chosenState = list[i];
                var splitChosenState = list[i].split(" ");
                if (splitChosenState.length > 1)
                    chosenState = splitChosenState[splitChosenState.length - 2];
                chosenState = chosenState.toUpperCase();
                chosenState = chosenState.substring(0, 2);

                var stateInArray = cachedStateLocations[chosenState];
                if (stateInArray == undefined) {
                    $('#output').val("Unrecognized state: " + chosenState);
                    return;
                }

                var min = Number.MAX_SAFE_INTEGER;
                var chosenDepot;
                //Find the most efficient depot
                for (var searchDepots = 0; searchDepots < cachedDistances.length; searchDepots++) {
                    var weight = cachedDistances[searchDepots].distances[stateInArray].weight;
                    if (weight < min) {
                        min = weight;
                        chosenDepot = cachedDistances[searchDepots].name
                    }
                }
                var depotName;
                //Assign out the count to the most efficient depot
                for (var j = 0; j < depotList.length; j++) {
                    if (depotList[j].state == chosenDepot) {
                        depotList[j].assigned++;
                        depotName = depotList[j].name;
                        break;
                    }
                }

                document.getElementById("output").innerHTML += depotName + "\n";
            }

            document.getElementById("ftw").innerHTML = depotList[0].assigned;
            document.getElementById("oma").innerHTML = depotList[1].assigned;
            document.getElementById("gso").innerHTML = depotList[2].assigned;
        }


        function fairObj(name, weight, chosenDepot, state) {
            this.name = name; //Newest location
            this.weight = weight;
            this.chosenDepotArrayLoc = chosenDepot;
            this.stateInArray = state; //Actual state index
        }

        function calculateDistanceFair() {
            document.getElementById("output").innerHTML = "";
            //Split the list and set the arrays
            var list = document.getElementById("input").value;
            var availableDepots = [],
                depotSelectionHolder = [],
                originalDepotList = [];
            for (var i = 0; i < depotList.length; i++) {
                availableDepots.push(depotList[i]);
                depotSelectionHolder.push([]);
            }
            list = list.trim();
            list = list.split("\n");

            for (var i = 0; i < list.length; i++) {
                //Logic for handling reading full addresses and state abbreviations
                var chosenState = list[i];
                var splitChosenState = list[i].split(" ");
                if (splitChosenState.length > 1)
                    chosenState = splitChosenState[splitChosenState.length - 2];
                chosenState = chosenState.toUpperCase();
                chosenState = chosenState.substring(0, 2);

                var stateInArray = cachedStateLocations[chosenState];
                if (stateInArray == undefined) {
                    $("#output").text("Unrecognized state: " + chosenState);
                    return;
                }

                var min = Number.MAX_SAFE_INTEGER;
                var chosenDepot, chosenDepotArrayLocation;
                //Find the most efficient depot
                for (
                    var searchDepots = 0;
                    searchDepots < cachedDistances.length;
                    searchDepots++
                ) {
                    var weight = cachedDistances[searchDepots].distances[stateInArray].weight;
                    if (weight < min) {
                        min = weight;
                        chosenDepot = cachedDistances[searchDepots].name;
                        chosenDepotArrayLocation = searchDepots;
                    }
                }
                var fairObj_instance = new fairObj(
                    chosenDepot,
                    min,
                    chosenDepotArrayLocation,
                    stateInArray
                );
                originalDepotList.push(fairObj_instance);
                depotSelectionHolder[chosenDepotArrayLocation].push(fairObj_instance);
            }
            var sortedArrays = availableDepots.length;
            //Complete the sort and repeat method
            while (sortedArrays-- > 1) {
                //Sort and decide which location has the most shipments
                var max = 0,
                    maxLocation;
                for (var loc = 0; loc < availableDepots.length; loc++) {
                    if (availableDepots[loc] == null) continue;
                    depotSelectionHolder[loc].sort(function (a, b) {
                        return a.weight - b.weight;
                    });
                    if (depotSelectionHolder[loc].length > max) {
                        max = depotSelectionHolder[loc].length;
                        maxLocation = loc;
                    }
                }
                //If max size is only equal to the evened out value, then we can just break out of this
                if (max / originalDepotList.length <= 1 / availableDepots.length) break;
                //Take out the available depot for later calculations
                availableDepots[maxLocation] = null;
                //Calculate what array will be worked on
                var arrSlice = Math.round(
                    (1 / depotSelectionHolder.length) *
                    depotSelectionHolder[maxLocation].length
                );
                var extraDepots = depotSelectionHolder[maxLocation].splice(-arrSlice, arrSlice); //Moves end of array to extra depots for further processing

                for (var i = 0; i < extraDepots.length; i++) {
                    var stateInArray = extraDepots[i].name;
                    //Find the most efficient depot
                    var min = Number.MAX_SAFE_INTEGER;
                    var chosenDepot, chosenDepotArrayLocation;
                    for (
                        var searchDepots = 0;
                        searchDepots < cachedDistances.length;
                        searchDepots++
                    ) {
                        if (availableDepots[searchDepots] == null) continue;
                        var weight =
                            cachedDistances[searchDepots].distances[extraDepots[i].stateInArray]
                                .weight;
                        if (weight < min) {
                            min = weight;
                            chosenDepot = cachedDistances[searchDepots].name;
                            chosenDepotArrayLocation = searchDepots;
                        }
                    }
                    if (extraDepots[i].weight + 700 < min) continue;
                    extraDepots[i].name = chosenDepot;
                    extraDepots[i].weight = min;
                    extraDepots[i].chosenDepotArrayLoc = chosenDepotArrayLocation;
                    depotSelectionHolder[chosenDepotArrayLocation].push(
                        extraDepots[i]
                    );
                }
            }

            var chosenDepot;
            //Assign out the count to the most efficient depot
            for (var j = 0; j < originalDepotList.length; j++) {
                chosenDepot = originalDepotList[j];
                depotList[chosenDepot.chosenDepotArrayLoc].assigned++;
                document.getElementById("output").innerHTML +=
                    depotList[chosenDepot.chosenDepotArrayLoc].name + "\n";
            }
            document.getElementById("ftw").innerHTML = depotList[0].assigned;
            document.getElementById("oma").innerHTML = depotList[1].assigned;
            document.getElementById("gso").innerHTML = depotList[2].assigned;
        }

        function displayHelp() {
            alert(
                "This page is used for determining shipping locations based off of state abbreviations. There are two formats of addresses that are accepted. One is with just the state abbreviation alone, or as a full address. Both examples are displayed in the input text field. This is used as a bulk adder for calculating depot shipping locations. It uses a generalized algorithm that I made for calculating distances that values speed over actual distance calculation."
            );
            document.getElementById("input").value = "IN\n501 Virginia Ave, Hagerstown, MD 21740"
        }


    </script>
</body>
</html>
