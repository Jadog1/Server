<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>4D Method Converter</title>
    <%- include('../partials/Header') %>

    <style>
        th,
        td {
            border: 1px black groove;
        }

        #log {
            display:none
        }
    </style>
</head>
<body>
    <%- include('../partials/navbar') %>
     <div class="w3-row-padding w3-padding-64 w3-container">
         <h1>4D ordering list</h1>
         <textarea id="input" placeholder="input" rows="15" cols="70"></textarea>
         <button onclick="convert()">Order list</button>
         <textarea id="output" placeholder="output" rows="15" cols="70" readonly="readonly"></textarea>
         <br />
         <button onclick="$('#log').toggle(); $('#log').text(outputConsole.detailedLog)">Toggle current log</button>
         <textarea id="log" placeholder="log" rows="5" cols="100" readonly="readonly"></textarea>

         <h3>Update notes (v1):</h3>
         Not quite ready for full copy and pasting methods... Check below "to add"
         <table>
             <tr>
                 <th>Working</th>
                 <th>To add</th>
             </tr>
             <tr>
                 <td>Format variable global types ($, process, and <>) alphabetically</td>
                 <td>Change non-conforming local var names</td>
             </tr>
             <tr>
                 <td>Place parameter inits at top of page</td>
                 <td>Add parameter declaration under parameter inits</td>
             </tr>
             <tr>
                 <td>Place headers at top of page</td>
                 <td>Add ticket init and declaration under header</td>
             </tr>
             <tr>
                 <td>Place code at bottom of page</td>
                 <td></td>
             </tr>
             <tr>
                 <td>Place array inits under code initalization</td>
                 <td></td>
             </tr>
         </table>
     </div>


    <script>
        var outputConsole = { detailedLog: "" };
        outputConsole.log = function (val) {
            this.detailedLog += (new Date().toLocaleTimeString()) + " - " + val + "\n"
        };

        function varTypes() {
            this.text = { name: "C_TEXT", arr: [], output: "", initial: "t" };
            this.number = { name: "C_LONGINT", arr: [], output: "", initial: "l" };
            this.date = { name: "C_DATE", arr: [], output: "", initial: "d" };
            this.time = { name: "C_TIME", arr: [], output: "", initial: "t" };
            this.bool = { name: "C_BOOLEAN", arr: [], output: "", initial: "b" };
            this.pict = { name: "C_PICTURE", arr: [], output: "", initial: "-" };
            this.pict = { name: "C_POINTER", arr: [], output: "", initial: "p" };
            this.real = { name: "C_REAL", arr: [], output: "" };
            this.blob = { name: "C_BLOB", arr: [], output: "" };
            this.obj = { name: "C_OBJECT", arr: [], output: "" };
            this.collection = { name: "C_COLLECTION", arr: [], output: "" };
        }
        var interprocess = new varTypes();
        var process = new varTypes();
        var local = new varTypes();
        var gatheredArrays = [];
        var headerComments = [];
        var otherCode = [];
        var parameters = [];
        var varTypesAllNames = [];
        function loadVarTypesAllNames() {
            var obj = new varTypes();
            for (var variable in obj) {
                variable = obj[variable];
                varTypesAllNames.push(variable.name);
            }
        }
        loadVarTypesAllNames();

        function loopThroughGivenVarType(type, typeVariableText) {
            var output = "";
            var hasArrs = false,
                commentIndexOnLine,
                variableArr_VarOutput,
                variableArr_VarComment;
            for (var variable in type) {
                variable = type[variable];
                //console.log(variable);
                if (variable.arr.length != 0) {
                    hasArrs = true;
                    variable.arr.sort();
                    variable.output += variable.name + "(";

                    for (var i = 0; i < variable.arr.length; i++) {
                        //Check to see if a variable has a comment. If so, store the comment to be added
                        commentIndexOnLine = variable.arr[i].search("//");
                        if (commentIndexOnLine != -1) {
                            variableArr_VarOutput = variable.arr[i].substring(
                                0,
                                commentIndexOnLine
                            );
                            variableArr_VarComment = variable.arr[i].substring(
                                commentIndexOnLine,
                                variable.arr[i].length
                            );
                        } else {
                            variableArr_VarOutput = variable.arr[i];
                            variableArr_VarComment = "";
                        }

                        variable.output += variableArr_VarOutput;
                        if (i + 1 != variable.arr.length)
                            variable.output += "; \\ " + variableArr_VarComment + "\n";
                        //Add end of line for multi-line
                        else variable.output += ") " + variableArr_VarComment + "\n\n"; //Add end of line for end of var declaration
                    }
                    output += variable.output;
                    variable.arr.splice(0, variable.arr.length);
                    variable.output = "";
                }
            }

            if (hasArrs) output = "//" + typeVariableText + "\n" + output + "\n"; //Display information only if variable type applies
            return output;
        }

        function loopThroughVarTypes() {
            var output = "",
                i;
            //Set up header
            for (i = 0; i < headerComments.length; i++)
                output += headerComments[i] + "\n";
            if (headerComments.length > 0) output += "\n\n";

            //Set up parameters
            parameters.sort(function (a, b) {
                if (a.param < b.param) return -1;
                else if (a.param > b.param) return 1;
                else return 0;
            });
            for (i = 0; i < parameters.length; i++) output += parameters[i].line + "\n";
            if (parameters.length > 0) output += "\n";

            //Set up variable declaration
            output += loopThroughGivenVarType(local, "Local");
            output += loopThroughGivenVarType(process, "Process");
            output += loopThroughGivenVarType(interprocess, "Interprocess");

            //Set up arrays
            gatheredArrays.sort();
            for (i = 0; i < gatheredArrays.length; i++)
                output += gatheredArrays[i] + "\n\n";

            //Fill in all other code
            for (i = 0; i < otherCode.length; i++) output += otherCode[i] + "\n";

            //Empty out arrays for future use
            gatheredArrays.splice(0, gatheredArrays.length);
            headerComments.splice(0, headerComments.length);
            otherCode.splice(0, otherCode.length);
            parameters.splice(0, parameters.length);

            document.getElementById("output").value = output;
            $('#log').text(outputConsole.detailedLog)
        }

        function extractLineToVar(varGlobalType, varAt, state, splitInput) {
            var foundVarName = false;
            for (var variable in varGlobalType) {
                variable = varGlobalType[variable];
                var varTypeName = splitInput.substring(0, splitInput.search("\\("));
                var commentIndex = splitInput.search("//");
                var commentOnLine = splitInput.substring(
                    commentIndex == -1 ? splitInput.length : commentIndex,
                    splitInput.length
                );
                if (variable.name === varTypeName || variable.name === state) {
                    foundVarName = true;
                    variable.arr.push(varAt + commentOnLine);
                    break;
                }
            }
            if (!foundVarName) {
                outputConsole.log("Threw line into otherCode " + splitInput);
                otherCode.push(splitInput);
            }
        }

        function convert() {
            document.getElementById("output").value = "";
            outputConsole.detailedLog = ""
            var foundASplit = false,
                varAt,
                state = "",
                hasHeaderComments = true,
                regex;
            var input = document.getElementById("input").value;
            var splitInput = input.split("\n");
            for (var i = 0; i < splitInput.length; i++) {
                //Load the header comments
                if (hasHeaderComments) {
                    if (splitInput[i].trim().startsWith("//")) {
                        outputConsole.log("Adding header to headerComments " + splitInput[i]);
                        headerComments.push(splitInput[i]);
                        continue;
                    } else hasHeaderComments = false;
                }

                if (splitInput[i].trim().startsWith("//")) {
                    outputConsole.log("Threw commented line into otherCode " + splitInput[i]);
                    otherCode.push(splitInput[i]);
                    continue;
                }

                //Test if loading an array line
                regex = new RegExp("(array (.+\\(.+\\)))");
                if (regex.test(splitInput[i].toLowerCase())) {
                    gatheredArrays.push(splitInput[i]);
                    continue;
                }

                //Test if loading a parameter line
                regex = new RegExp("\\$[0-9]+");
                if (regex.test(splitInput[i])) {
                    var regexMatchObj = splitInput[i].match(regex);
                    parameters.push({
                        line: regexMatchObj.input,
                        param: parseInt(regexMatchObj[0].substring(1, regexMatchObj[0].length))
                    });
                    continue;
                }

                //Set varAt if single line variable
                if (
                    splitInput[i].search("\\(") != -1 &&
                    splitInput[i].search("\\)") != -1 &&
                    state == ""
                ) {
                    varAt = splitInput[i].substring(
                        splitInput[i].search("\\(") + 1,
                        splitInput[i].search("\\)")
                    );
                    //Set varAt if multi-line variable
                } else if (
                    (splitInput[i].trim().endsWith("\\") &&
                        splitInput[i].search(";") != -1) ||
                    foundASplit
                ) {
                    if (state == "")
                        state = splitInput[i].substring(0, splitInput[i].search("\\("));

                    if (splitInput[i].search(";") == -1) {
                        //Check if last line in multi-line
                        varAt = splitInput[i].substring(0, splitInput[i].search("\\)"));
                        foundASplit = false;
                    } else {
                        //Otherwise process other multi-line variables
                        var regex = new RegExp("(C_[a-zA-Z]+)(\\(.+)");
                        var regexResult = regex.test(splitInput[i]);
                        var indexStartAt = regexResult ? splitInput[i].search("\\(") + 1 : 0; //Checks if first line
                        varAt = splitInput[i].substring(
                            indexStartAt,
                            splitInput[i].search(";")
                        );
                        foundASplit = true;
                    }
                }
                //Check if a a newline or unrecognized line of code
                if (varAt == undefined) {
                    otherCode.push(splitInput[i] + "\n");
                    continue;
                }
                //Check for broken copies of variables (EG: C_LONGINT(C_BOOLEAN($val))) that can happen from bad state logic
                if (state != "") {
                    for (var k = 0; k < varTypesAllNames.length; k++) {
                        if (varAt.startsWith(varTypesAllNames[k])) {
                            outputConsole.log(
                                "Discrepancy found in variable state, attempting refresh. varAt: " +
                                varAt
                            );
                            state = "";
                            foundASplit = false;
                            i--;
                        }
                    }
                    if (state == "") continue;
                }

                //Check if varAt is multiple variables
                var splitVarAt = varAt.split(";");
                for (var j = 0; j < splitVarAt.length; j++) {
                    varAt = splitVarAt[j].trim();
                    if (varAt != undefined) {
                        if (varAt[0] === "<") {
                            extractLineToVar(interprocess, varAt, state, splitInput[i]);
                        } else if (varAt[0] == "$") {
                            extractLineToVar(local, varAt, state, splitInput[i]);
                        } else if (varAt[0].match(/[a-z]/i)) {
                            extractLineToVar(process, varAt, state, splitInput[i]);
                        } else {
                            outputConsole.log("Threw line into otherCode " + splitInput[i]);
                            otherCode.push(splitInput[i]);
                        }

                        if (foundASplit == false && state != "") state = "";
                    }
                }
            }

            loopThroughVarTypes();
        }

    </script>
</body>
</html>
